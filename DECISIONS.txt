DESIGN DECISIONS - BITA Mini Backtest API
==========================================

1. ARCHITECTURE & DESIGN PATTERNS
----------------------------------

SOLID Principles & Factory Pattern
- Used factory pattern for Calendar, Filter, and Weighting components
- Easy to extend with new strategies without modifying existing code
- Each class has single responsibility (SRP)
- Dependency injection via FastAPI dependencies

Discarded: Monolithic approach
- Would make code harder to test and extend
- Violates SOLID principles

Async-First Architecture
- FastAPI with async/await throughout
- Non-blocking LLM API calls
- Better scalability under concurrent load

Discarded: Synchronous blocking implementation
- Would limit throughput
- Poor performance under load


2. DATA STORAGE & PROCESSING
-----------------------------

DuckDB for Data Queries
- Columnar database optimized for analytical queries
- In-memory or file-based operation
- Native Parquet support
- Vectorized query execution (10-100x faster than pandas)

Discarded: Pure pandas/in-memory approach
- Slower for large datasets
- Limited SQL capabilities
- Higher memory footprint

Parquet File Format
- Columnar storage, efficient compression
- Native support in DuckDB and pandas
- Industry standard for time-series data

Discarded: CSV files
- Slower to read/write
- No compression
- Type information lost

Local Filesystem (Demo)
- S3DataService implemented but not used
- Simpler deployment for demo
- No AWS dependencies or costs

Discarded: S3 for demo deployment
- Unnecessary complexity for demo
- Additional AWS configuration required
- Cost implications


3. LLM INTEGRATION
------------------

Multi-Provider Support (OpenAI/Gemini/OpenLLM)
- Abstract base class (BaseChatClient)
- Factory pattern for client instantiation
- Easy to add new providers

Discarded: Single provider lock-in
- Vendor lock-in risk
- No fallback options
- Less flexible

Structured JSON Output
- Explicit JSON schema in system prompt
- Pydantic validation of LLM responses
- Type-safe throughout the stack

Discarded: Free-form text parsing
- Unreliable
- Complex regex/parsing logic
- Error-prone

Error Handling & Retries
- HTTP errors caught and wrapped
- JSON parsing errors handled gracefully
- Pydantic validation with clear error messages

Discarded: Fail-fast approach
- Poor user experience
- No resilience


4. API DESIGN
-------------

Pydantic V2 for Validation
- Runtime type checking
- Automatic OpenAPI schema generation
- Custom validators for security (SQL injection, path traversal)

Custom Exception Hierarchy
- Domain-specific exceptions (DatabaseError, PromptParsingError, etc.)
- Proper HTTP status code mapping
- User-friendly error messages

Discarded: Generic exceptions
- Less informative
- Harder to debug
- Poor API documentation


5. TESTING STRATEGY
-------------------

88% Test Coverage (152 tests)
- Comprehensive edge case testing
- Mocked external dependencies (LLM APIs, file system)
- Async test support with pytest-asyncio

Discarded: Manual testing only
- Not scalable
- No regression detection
- Time-consuming


6. DEPLOYMENT & DEVOPS
----------------------

Docker + docker-compose
- Single-stage Dockerfile for simplicity
- System-wide uv installation
- Easy local development

Discarded: Multi-stage build
- Venv path issues in container
- Added complexity for minimal benefit

Render for Hosting
- Free tier available for demo
- Zero-downtime deployments
- Automatic HTTPS

Discarded: AWS/Terraform infrastructure
- Over-engineered for demo scope
- Significant time investment
- Cost considerations

UV Package Manager
- 10-100x faster than pip
- Reproducible builds
- Modern dependency resolution

Discarded: pip/requirements.txt
- Slower dependency resolution
- No lock file by default


7. CODE QUALITY & MAINTAINABILITY
----------------------------------

Ruff for Linting + Formatting
- Fast (written in Rust)
- Replaces multiple tools (black, isort, flake8)
- Configurable via pyproject.toml

Pre-commit Hooks
- Automatic linting before commits
- Prevents CI failures
- Consistent code style

Type Hints + mypy
- Static type checking
- Better IDE support
- Catches bugs early

Structured Logging (JSON)
- Machine-readable logs
- Easy integration with log aggregators
- Production-ready

Discarded: Print statements
- Not production-ready
- Hard to filter/search


8. SECURITY CONSIDERATIONS
--------------------------

Input Validation
- SQL injection prevention
- Path traversal checks
- Pydantic validators for data_field

Secrets Management
- SecretStr for API keys
- Environment variables
- No hardcoded secrets

CORS Configuration
- Configured for API access
- Environment-specific settings


9. DEVELOPMENT WORKFLOW
-----------------------

Makefile for Common Tasks
- Simplified developer experience
- Consistent commands across team
- Easy onboarding

Git Workflow (main/develop branches)
- Clean main branch history
- Squash merges for features
- CI/CD on every push

Comprehensive README
- Setup instructions
- Architecture diagrams
- API examples
- Troubleshooting guide


10. TRADE-OFFS & FUTURE IMPROVEMENTS
------------------------------------

Accepted Trade-offs:
- Local storage over S3 (demo simplicity vs. production scalability)
- Single rebalance frequency (Quarterly) vs. multiple options
- Basic equal weighting vs. advanced strategies
- Synchronous backtest execution vs. async task queue

Future Enhancements (if more time):
- Redis caching for LLM responses
- Celery/RQ for async background tasks
- More rebalance frequencies (Monthly, Weekly)
- Additional weighting schemes (Market-cap weighted, Risk-parity)
- WebSocket for real-time progress updates
- Metrics/monitoring (Prometheus, Grafana)
- Rate limiting for API endpoints


CONCLUSION
----------

The design prioritizes:
1. Clean, maintainable code (SOLID principles)
2. Production-readiness (testing, logging, error handling)
3. Developer experience (documentation, tooling, automation)
4. Performance (DuckDB, async, Parquet)
5. Extensibility (factory patterns, abstract base classes)

Every decision was made with scalability and maintainability in mind,
demonstrating enterprise-level software engineering practices within
the 3-day time constraint.
